import Line2D from "../geometric/Line2D"
import Point2D from "../geometric/Point2D"
import Vector2D from "../geometric/Vector2D"
import { MathX } from "../util/MathX"

test("constructor should accept 5 overloads", () => {
  const l1 = new Line2D(10, 20, 30, 40)
  expect(l1.x).toBe(10)
  expect(l1.y).toBe(20)
  expect(l1.end.x).toBe(30)
  expect(l1.end.y).toBe(40)
  const l2 = Line2D.fromPoints(l1, l1.end)
  expect(l2 === l1).toBe(false)
  expect(l2.x).toBe(10)
  expect(l2.y).toBe(20)
  expect(l2.end.x).toBe(30)
  expect(l2.end.y).toBe(40)

  const p1 = new Point2D(10, 55)
  const v1 = new Vector2D(15, 45)
  const l3 = Line2D.fromPoints(p1, v1)
  expect(l3.x).toBe(10)
  expect(l3.y).toBe(55)
  expect(l3.end.x).toBe(15)
  expect(l3.end.y).toBe(45)

  const p2 = new Point2D(15, 15)
  const l4_1 = Line2D.fromPointAndAngle(p2, -Math.PI / 4, 10)
  const l4_2 = Line2D.fromPointAndAngle(p2, -MathX.deg45, 10)
  expect(l4_1.x).toBe(15)
  expect(l4_1.y).toBe(15)
  expect(l4_2.x).toBe(15)
  expect(l4_2.y).toBe(15)
  expect(l4_1.end.x).toBeCloseTo(22.07)
  expect(l4_2.end.x).toBeCloseTo(22.07)
  expect(l4_1.end.y).toBeCloseTo(7.9289)
  expect(l4_2.end.y).toBeCloseTo(7.9289)
  expect(l4_1.angle()).toBeCloseTo(-MathX.deg45, 6)
  expect(l4_2.angle()).toBeCloseTo(-MathX.deg45, 6)

  const l5_1 = Line2D.fromPointAndAngle(new Point2D(10, 10), Math.PI / 4, 100)
  const l5_2 = Line2D.fromPointAndAngle(new Point2D(10, 10), MathX.deg45, 100)
  expect(l5_1.x).toBe(10)
  expect(l5_2.x).toBe(10)
  expect(l5_1.y).toBe(10)
  expect(l5_2.y).toBe(10)
  expect(l5_1.angle()).toBeCloseTo(MathX.deg45, 6)
  expect(l5_2.angle()).toBeCloseTo(MathX.deg45, 6)
  expect(l5_1.length()).toBeCloseTo(100, 6)
  expect(l5_2.length()).toBeCloseTo(100, 6)
})

test("cloneLine should return new line", () => {
  const l1 = new Line2D(10, 20, 30, 40)
  const l2 = l1.cloneAsLine()
  l1.moveLineBy(new Vector2D(30, 30))
  expect(l1.x).toBe(40)
  expect(l1.y).toBe(50)
  expect(l1.end.x).toBe(60)
  expect(l1.end.y).toBe(70)
  expect(l2 === l1).toBe(false)
  expect(l2.x).toBe(10)
  expect(l2.y).toBe(20)
  expect(l2.end.x).toBe(30)
  expect(l2.end.y).toBe(40)
})

test("angle should return correct number", () => {
  const l1 = new Line2D(10, 10, 10, 40)
  const ang1 = l1.angle()
  expect(ang1).toBeCloseTo(MathX.deg90)
  const l2 = new Line2D(10, 10, 40, 40)
  const ang2 = l2.angle()
  expect(ang2).toBeCloseTo(MathX.deg45)
  const l3 = Line2D.fromPointAndAngle(new Point2D(10, 10), MathX.deg45, 10)
  const ang3 = l3.angle()
  expect(ang3).toBeCloseTo(Math.PI / 4)
  const l4 = new Line2D(50, 50, 40, 40)
  const ang4 = l4.angle()
  expect(ang4).toBeCloseTo(-MathX.deg135)
})

test("length should return correct number", () => {
  const l1 = new Line2D(10, 10, 10, 40)
  const len1 = l1.length()
  expect(len1).toBe(30)
  const l2 = new Line2D(50, 40, 10, 10)
  const len2 = l2.length()
  expect(len2).toBe(50)
})

test("reverse should return same line reversed", () => {
  const l1 = new Line2D(10, 20, 30, 40)
  const l2 = l1.reverse()
  expect(l2 === l1).toBe(true)
  expect(l2.x).toBe(30)
  expect(l2.y).toBe(40)
  expect(l2.end.x).toBe(10)
  expect(l2.end.y).toBe(20)
})

test("deltaVector should return new vector", () => {
  const l1 = new Line2D(10, 20, 30, 45)
  const v1 = l1.deltaVector()
  expect(v1.x).toBe(20)
  expect(v1.y).toBe(25)
})

test("deltaVectorBack should return new vector", () => {
  const l1 = new Line2D(10, 20, 30, 45)
  const v1 = l1.deltaVectorBack()
  expect(v1.x).toBe(-20)
  expect(v1.y).toBe(-25)
})

test("rotateFromP1 should return same rotated line", () => {
  const l1 = Line2D.fromPointAndAngle(new Point2D(100, 100), 0, 10)
  const l2 = l1.rotateFromP1(MathX.deg90)
  expect(l2 === l1).toBe(true)
  expect(l1.x).toBe(100)
  expect(l1.y).toBe(100)
  expect(l1.end.x).toBe(100)
  expect(l1.end.y).toBe(110)
  l1.rotateFromP1(Math.PI)
  expect(l1.end.x).toBe(100)
  expect(l1.end.y).toBe(90)
})

test("rotateFromP2 should return same rotated line", () => {
  const l1 = Line2D.fromPointAndAngle(new Point2D(100, 100), 0, 10)
  const l2 = l1.rotateFromP2(MathX.deg90)
  expect(l2 === l1).toBe(true)
  expect(l1.end.x).toBe(110)
  expect(l1.end.y).toBe(100)
  expect(l1.x).toBe(110)
  expect(l1.y).toBe(90)
  l1.rotateFromP2(Math.PI)
  expect(l1.end.x).toBe(110)
  expect(l1.end.y).toBe(100)
})

test("scaleLine", () => {
  const l1 = Line2D.fromPointAndAngle(new Vector2D(100, 100), MathX.deg45, 10)
  expect(l1.angle()).toBeCloseTo(MathX.deg45, 6)
  l1.scaleLineFromP1(2)
  expect(l1.angle()).toBeCloseTo(MathX.deg45, 6)
  expect(l1.length()).toBe(20)
})

test("scaleLineTo", () => {
  const l1 = Line2D.fromPointAndAngle(new Vector2D(100, 100), MathX.deg45, 10)
  expect(l1.angle()).toBeCloseTo(MathX.deg45, 6)
  l1.scaleLineTo(25)
  expect(l1.angle()).toBeCloseTo(MathX.deg45, 6)
  expect(l1.length()).toBe(25)
  expect(l1.x).toBe(100)
  expect(l1.y).toBe(100)
})

test("scaleLineToByP2", () => {
  const l1 = Line2D.fromPointAndAngle(new Vector2D(100, 100), MathX.deg45, 10)
  expect(l1.angle()).toBeCloseTo(MathX.deg45, 6)
  l1.scaleLineToByP2(25)
  expect(l1.angle()).toBeCloseTo(MathX.deg45, 6)
  expect(l1.length()).toBe(25)
  expect(l1.x).toBeCloseTo(89.39)
  expect(l1.y).toBeCloseTo(89.39)

  const l2 = new Line2D(100, 100, 110, 100)
  l2.scaleLineToByP2(25)
  expect(l2.length()).toBe(25)
  expect(l2.x).toBeCloseTo(85)
  expect(l2.y).toBeCloseTo(100)
})

test("moveLineToByP1 should return same line with 2 overloads", () => {
  const l1 = new Line2D(10, 10, 20, 20)
  l1.moveLineToByP1(new Vector2D(20, 20))
  expect(l1.x).toBe(20)
  expect(l1.y).toBe(20)
  expect(l1.end.x).toBe(30)
  expect(l1.end.y).toBe(30)
  const v1 = new Vector2D(5, 5)
  l1.moveLineToByP1(v1)
  expect(l1.x).toBe(5)
  expect(l1.y).toBe(5)
  expect(l1.end.x).toBe(15)
  expect(l1.end.y).toBe(15)
})

test("moveLineToByP2 should return same line with 2 overloads", () => {
  const l1 = new Line2D(10, 10, 20, 20)
  l1.moveLineToByP2(new Vector2D(10, 10))
  expect(l1.x).toBe(0)
  expect(l1.y).toBe(0)
  expect(l1.end.x).toBe(10)
  expect(l1.end.y).toBe(10)
  const v1 = new Vector2D(25, 25)
  l1.moveLineToByP2(v1)
  expect(l1.x).toBe(15)
  expect(l1.y).toBe(15)
  expect(l1.end.x).toBe(25)
  expect(l1.end.y).toBe(25)
})

test("moveLineTo should return same line with 2 overloads", () => {
  const l1 = new Line2D(10, 10, 20, 20)
  l1.moveLineTo(new Vector2D(15, 15), new Vector2D(25, 25))
  expect(l1.x).toBe(15)
  expect(l1.y).toBe(15)
  expect(l1.end.x).toBe(25)
  expect(l1.end.y).toBe(25)
  const v1 = new Vector2D(25, 25)
  const v2 = new Vector2D(50, 50)
  l1.moveLineTo(v1, v2)
  expect(l1.x).toBe(25)
  expect(l1.y).toBe(25)
  expect(l1.end.x).toBe(50)
  expect(l1.end.y).toBe(50)
})

test("moveLineBy should return same line with 2 (6 optional) overloads", () => {
  const l1 = new Line2D(10, 10, 20, 20)
  l1.moveLineBy(new Vector2D(10, 10))
  expect(l1.x).toBe(20)
  expect(l1.y).toBe(20)
  expect(l1.end.x).toBe(30)
  expect(l1.end.y).toBe(30)
  l1.moveLineBy(new Vector2D(-10, 10))
  expect(l1.x).toBe(10)
  expect(l1.y).toBe(30)
  expect(l1.end.x).toBe(20)
  expect(l1.end.y).toBe(40)
  l1.moveLineBy(new Vector2D(10, 15), new Vector2D(20, 25))
  expect(l1.x).toBe(20)
  expect(l1.y).toBe(45)
  expect(l1.end.x).toBe(40)
  expect(l1.end.y).toBe(65)
  const v1 = new Vector2D(5, 10)
  l1.moveLineBy(v1)
  expect(l1.x).toBe(25)
  expect(l1.y).toBe(55)
  expect(l1.end.x).toBe(45)
  expect(l1.end.y).toBe(75)
  const v2 = new Vector2D(5, 10)
  const v3 = new Vector2D(20, 15)
  l1.moveLineBy(v2, v3)
  expect(l1.x).toBe(30)
  expect(l1.y).toBe(65)
  expect(l1.end.x).toBe(65)
  expect(l1.end.y).toBe(90)
})

test("toString should return correct string", () => {
  const v1 = new Line2D(10, 15, 20, 25)
  const ss = v1.toString()
  expect(ss).toBe(`[Line2D(10,15,20,25)]`)
})
//    toString() {
//       return `[Line2D(${this.x},${this.y},${this.p.x},${this.p.y})]`
//    }

// }
